{-

-------------------------------------------------------------------------
-- Programming and proving with higher inductive types in Cubical Agda --
-------------------------------------------------------------------------

Talk by Anders Mörtberg in the Stockholm Logic Seminar, December 4, 2019.

Outline:

1. Higher inductive types in Book HoTT
2. Cubical Type Theory (CTT)
3. Higher inductive types in CTT
4. Cubical Agda
5. Higher inductive types in Cubical Agda


Higher inductive types in Book HoTT
-----------------------------------

An important new addition of Homotopy Type Theory (HoTT) is the notion
of *higher inductive type* (~ 2011). These generalize the regular
inductive types of type theory to also include non-trivial "higher"
constructors specifying elements of the identity type.

The semantics for these types in simplicial sets were worked out in
(modulo some caveats with universes):

Semantics of higher inductive types (2017)
Peter LeFanu Lumsdaine, Mike Shulman
https://arxiv.org/abs/1705.07088

Recall that in HoTT a type is thought of as a space and elements of
its identity type are paths in this space, elements of iterated
identity types then correspond to homotopies between these paths, etc.
With this intuition it's natural to extend the notion of type to also
include types generated by not just normal constructors, but also
constructors for elements of its identity type.

For example the circle, S¹, in Book HoTT is the HIT generated by

base : S¹
loop : Id S¹ base base

The non-dependent recursor says that given a type A and

a : A
l : Id A a a

we have

f : S¹ → A

with

f base ≡ a
Id (Id A a a) (cong f loop) l

Where, given f : A → B and p : Id A x y, we have cong f p : Id B (f x)
(f y) defined using J.

The dependent induction principle is a bit more complicated. Given P :
S¹ → U with

b : P base
l : subst P loop b = b    (written b =^P_loop b in HoTT book, "path-over")

we have

f : (x : S¹) → P x

Where, given P : A → U and p : Id A x y we have subst P p : P x → P y
defined using J.

The induction principle satisfies

f base ≡ b
Id (P b) (congD P f loop) l

Where, given P : A → U, f : (x : A) → P x and p : Id A x y, we have
congD P f p : Id (P y) (subst P p (f x)) (f y).

Remarks:

1. Elimination principle for higher constructors only hold up to Id.
2. Complicated because of subst/cong/congD.

Despite these complications LOTS of very impressive things have been
formalized using HITs in "Book HoTT". But because of these
complications many people started looking for a type theory with
*native* support for HITs where things compute better and things are
simpler (no subst/cong/congD). Cubical type theory is such a type
theory.


Cubical Type Theory (CTT)
-------------------------

The original motivation for CTT was to give constructive meaning to
Voevodsky's univalence axiom. Since then we have also found that it is
also a suitable system for higher inductive types. The original
formulation of CTT can be found in our paper from 2015 (popularly
referred to as CCHM after the first letter of the last name of each
author):

Cubical Type Theory: a constructive interpretation of the univalence axiom
Cyril Cohen, Thierry Coquand, Simon Huber, Anders Mörtberg
https://arxiv.org/abs/1611.02108

Since 2015 lots of new cubical type theories have been formulated by
various people and groups all over the world. In this talk I will be
working in the cubical type theory of Cubical Agda which is heavily
inspired by CCHM, but most of what I say will be true for other
formulations of CTT as well.

In CTT we have a primitive formal interval II with endpoints 0 : II
and 1 : II. A point i : II should be thought of a point varying
continuously between 0 and 1. These interval variables behave like
normal variables in type theory and can hence occur in the context. A type

i : II ⊢ A(i)

should be though of as a line between A(0) and A(1). We can bind
interval variables using λ-abstraction and apply them using normal
application.

Using interval variables we can introduce Path types as functions out
of the interval with specified endpoints. These should be thought of
as cubical substitutes for Id types in HoTT. In fact, these types lets
us define path-over types directly. Given A : I → U, x : A 0 and y : A
1 we define:

PathP A x y

as the dependent path type between x and y. These are also introduced
using λ-abstraction and eliminated using application. However, as the
interval has two special points 0 and 1 we have two special
computation rules for paths. Given p : PathP A x y we have

p 0 ≡ x
p 1 ≡ y

We can then define regular homogeneous/non-dependent path types in A :
U as:

Path A x y := PathP (λ (i : II) → A) x y

In Cubical Agda we write x ≡ y for Path A x y.


Higher inductive types in CTT
-----------------------------

In order to explain how HITs are represented in CTT let us revisit the
circle S¹. In CTT we can represent it as the type generated by the
constructors:

base : S¹
loop : II → S¹

satisfying loop 0 = loop 1 = base. Note that loop is just a normal
constructor of the type and not its Id/Path type (compare this to for
example "cons : A → List A → List A").

The non-dependent recursor says that given a type A and

a : A
l : II → A

with l 0 = l 1 = a we have

f : S¹ → A

s.t.

f base ≡ a
f (loop i) ≡ l i

Note that this is a judgmental/definitional equality also for the loop
constructor!

The dependent induction principle is not more complicated. Given P :
S¹ → U with

b : P base
l : (i : II) → P (loop i)

with l 0 = l 1 = b we have

f : (x : S¹) → P x

satisfying

f base ≡ b
f (loop i) ≡ l i

Note that there is no need for any cong/congD/subst!

Note that when we say that we have

l : (i : II) → P (loop i)

with l 0 = l 1 = b this is essentially like:

l : PathP (λ (i : II) → P (loop i)) b b

however for technical reasons we use "cubical subtypes" and instead
formalize this as:

l : (i : II) → P (loop i) [ (i = 0) ∨ (i = 1) ↦ b ]

For details about how this work see

On Higher Inductive Types in Cubical Type Theory (2018)
Thierry Coquand, Simon Huber, Anders Mörtberg
https://arxiv.org/abs/1802.01170

In this paper we also give a (constructive) semantics for HITs in
cubical sets and show that the approach taken to represent the circle
scales directly to more complicated HITs, including pushouts. As
things work very smoothly also for more complex HITs we were able to
give a sketch of schema for HITs in CTT and it is this that Cubical
Agda implements.


Cubical Agda
------------

Cubical Agda is a cubical extension of the Agda proof assistant that
provides Agda with the many nice features of CTT (constructive
univalence and HITs) without sacrificing the constructive nature of
Agda or decidability of type checking (at least conjecturally). We
have a paper about Cubical Agda where we go into technical details and
show many examples:

Cubical Agda: A Dependently Typed Programming Language with Univalence and Higher Inductive Types (2019)
Andrea Vezzosi, Anders Mörtberg, Andreas Abel

Cubical Agda implements the schema for HITs from our paper on HITs in
CTT and we have a by now rather large library on Github called
agda/cubical to which many people have contributed:

https://github.com/agda/cubical

I will now show many examples from the library coming from computer
science, algebra, logic and homotopy theory.

-}

-- To make Agda cubical add the following flag:
{-# OPTIONS --cubical #-}
module Cubical.Talk where

-- We import the Core part of the library
open import Cubical.Core.Everything

-- And the "Foundations" part containing a lot of important results
-- (in particular the univalence theorem).
open import Cubical.Foundations.Everything

-- We also import some useful datatypes.
open import Cubical.Data.Nat
open import Cubical.Data.Int
open import Cubical.Data.Prod hiding (_×_) renaming (_×Σ_ to _×_)


-- The interval in Cubical Agda is written I and the endpoints i0 and i1.

apply0 : (A : Set) (p : I → A) → A
apply0 A p = p i0

-- A proof of reflexivity is just the constant function out of the interval.
refl' : (A : Set) (x : A) → PathP (λ _ → A) x x
refl' A x = λ _ → x

-- We can write this nicer:
refl'' : {A : Set} (x : A) → x ≡ x
refl'' x _ = x

-- cong has a direct proof (not using J!)
cong' : {A B : Set} (f : A → B) {x y : A} (p : x ≡ y) → f x ≡ f y
cong' f p = λ i → f (p i)

-- function extensionality also has a direct proof.
-- It also has computational content: swap the arguments.
funExt' : {A B : Set} {f g : A → B} (p : (x : A) → f x ≡ g x) → f ≡ g
funExt' p = λ i x → p x i

-- We can prove J, doesn't satisfy computation rule
-- judgmentally/definitionally. Almost never a problem in practice as
-- the cubical primitives satisfy many new judgmental/definitional
-- equalities.

{-

Cubical Agda has many other features from CTT:

- connections - min/max operations on the interval
- reversals - "1 - x" involution on the interval
- hcomp - compose higher dimensional cubes
- transp - generalized transport
- Glue - used to prove univalence

As this talk is not really about Cubical Agda in general I won't go
into more details than necessary about this. For details see our
Cubical Agda paper.

For now what we have will be enough to do some simple examples.

-}


--------------------------------------------
-- Higher inductive types in Cubical Agda --
--------------------------------------------

-- We can define the circle as the following simple data declaration:
data S¹ : Set where
  base : S¹
  loop : base ≡ base

-- We can write functions on S¹ using pattern-matching equations:
double : S¹ → S¹
double base = base
double (loop i) = (loop ∙ loop) i

helix : S¹ → Set
helix base     = Int
helix (loop i) = sucPathInt i

ΩS¹ : Set
ΩS¹ = base ≡ base

winding : ΩS¹ → Int
winding p = transport (λ i → helix (p i)) (pos 0)

test0 : Int
test0 = winding (loop ∙ loop)

-- We can define the Torus as:
data Torus : Set where
  point : Torus
  line1 : point ≡ point
  line2 : point ≡ point
  square : PathP (λ i → line1 i ≡ line1 i) line2 line2

-- And prove that it is equivalent to two circle:
t2c : Torus → S¹ × S¹
t2c point        = ( base , base )
t2c (line1 i)    = ( loop i , base )
t2c (line2 j)    = ( base , loop j )
t2c (square i j) = ( loop i , loop j )

c2t : S¹ × S¹ → Torus
c2t (base   , base)   = point
c2t (loop i , base)   = line1 i
c2t (base   , loop j) = line2 j
c2t (loop i , loop j) = square i j

c2t-t2c : ∀ (t : Torus) → c2t (t2c t) ≡ t
c2t-t2c point        = refl
c2t-t2c (line1 _)    = refl
c2t-t2c (line2 _)    = refl
c2t-t2c (square _ _) = refl

t2c-c2t : ∀ (p : S¹ × S¹) → t2c (c2t p) ≡ p
t2c-c2t (base   , base)   = refl
t2c-c2t (base   , loop _) = refl
t2c-c2t (loop _ , base)   = refl
t2c-c2t (loop _ , loop _) = refl

-- Using univalence we get the following equality:
Torus≡S¹×S¹ : Torus ≡ S¹ × S¹
Torus≡S¹×S¹ = isoToPath (iso t2c c2t t2c-c2t c2t-t2c)

-- More results about the circle can be found in the library.
-- Including: ΩS¹≡Int : ΩS¹ ≡ Int
open import Cubical.HITs.S1

-- We can combine this with the above equality between the Torus and
-- two circles to compute winding numbers on the Torus:
open import Cubical.HITs.Torus renaming (line1 to l1 ; line2 to l2)

test1 : windingTorus (l1 ∙ l2) ≡ (pos 1 , pos 1)
test1 = refl

-- We have many more topological examples, including Klein bottle,
-- higher spheres and suspensions:
open import Cubical.HITs.KleinBottle
open import Cubical.HITs.S2
open import Cubical.HITs.S3
open import Cubical.HITs.Susp

-- No Möbius strip yet! Room for improvement...

-- These were all examples taken from topology. Let us now do some
-- more computer scientific examples!



                      --------------
                      -- Integers --
                      --------------

{-
To represent the integers one typically use the sum type ℕ + ℕ,
however one get two zeroes "inl 0" and "inr 0". People typically deal
with this by saying that "inr n" is "- (n+1)", but it easily gets
confusing and one can end up with off-by-one errors. A better solution
would be to identify "inl 0" and "inr 0".
-}
data ℤ : Type₀ where
  pos    : (n : ℕ) → ℤ
  neg    : (n : ℕ) → ℤ
  posneg : pos 0 ≡ neg 0

-- It is easy to prove that ℤ = ℕ + ℕ. Let's do some programming with
-- ℤ directly instead:
sucℤ : ℤ → ℤ
sucℤ (pos n)       = pos (suc n)
sucℤ (neg zero)    = pos 1
sucℤ (neg (suc n)) = neg n
sucℤ (posneg _)    = pos 1

predℤ : ℤ → ℤ
predℤ (pos zero)    = neg 1
predℤ (pos (suc n)) = pos n
predℤ (neg n)       = neg (suc n)
predℤ (posneg _)    = neg 1

sucPredℤ : ∀ n → sucℤ (predℤ n) ≡ n
sucPredℤ (pos zero)    = sym posneg
sucPredℤ (pos (suc _)) = refl
sucPredℤ (neg _)       = refl
sucPredℤ (posneg i) j  = posneg (i ∨ ~ j)

predSucℤ : ∀ n → predℤ (sucℤ n) ≡ n
predSucℤ (pos _)       = refl
predSucℤ (neg zero)    = posneg
predSucℤ (neg (suc _)) = refl
predSucℤ (posneg i) j  = posneg (i ∧ j)

sucPathℤ : ℤ ≡ ℤ
sucPathℤ  = isoToPath (iso sucℤ predℤ sucPredℤ predSucℤ)

predPathℤ : ℤ ≡ ℤ
predPathℤ = isoToPath (iso predℤ sucℤ predSucℤ sucPredℤ)

-- We now have non-trivial successor and predecessor paths on ℤ. We
-- can use these to define addition and subtraction so that they are
-- trivially equivalences.
addEqℤ : ℕ → ℤ ≡ ℤ
addEqℤ zero    = refl
addEqℤ (suc n) = addEqℤ n ∙ sucPathℤ

subEqℤ : ℕ → ℤ ≡ ℤ
subEqℤ zero    = refl
subEqℤ (suc n) = subEqℤ n ∙ predPathℤ

addℤ : ℤ → ℤ → ℤ
addℤ m (pos n)    = transport (addEqℤ n) m
addℤ m (neg n)    = transport (subEqℤ n) m
addℤ m (posneg _) = m

test : ℤ
test = addℤ (pos 3) (neg 8)

isEquivAddℤ : (m : ℤ) → isEquiv (λ n → addℤ n m)
isEquivAddℤ (pos n)    = isEquivTransport (addEqℤ n)
isEquivAddℤ (neg n)    = isEquivTransport (subEqℤ n)
isEquivAddℤ (posneg _) = isEquivTransport refl

-- We can define addition directly as well
_+ℤ_ : ℤ → ℤ → ℤ
m +ℤ (pos (suc n)) = sucℤ (m +ℤ pos n)
m +ℤ (neg (suc n)) = predℤ (m +ℤ neg n)
m +ℤ _             = m

-- And prove that it is equal to addℤ using binary funext
addℤ≡+ℤ : addℤ ≡ _+ℤ_
addℤ≡+ℤ i  m (pos (suc n)) = sucℤ (addℤ≡+ℤ i m (pos n))
addℤ≡+ℤ i  m (neg (suc n)) = predℤ (addℤ≡+ℤ i m (neg n))
addℤ≡+ℤ i  m (pos zero)    = m
addℤ≡+ℤ i  m (neg zero)    = m
addℤ≡+ℤ _  m (posneg _)    = m

-- We then directly get that +ℤ is an equivalence
isEquiv+ℤ : (m : ℤ) → isEquiv (λ n → n +ℤ m)
isEquiv+ℤ = subst (λ _+_ → (m : ℤ) → isEquiv (λ n → n + m)) addℤ≡+ℤ isEquivAddℤ

-- This example can be found in:
open import Cubical.HITs.Ints.QuoInt

-- Other encodings of integers:

-- data BiInvInt : Type₀ where
--   zero : BiInvInt
--   suc : BiInvInt -> BiInvInt

--   -- suc is a bi-invertible equivalence:
--   predr : BiInvInt -> BiInvInt
--   suc-predr : ∀ z -> suc (predr z) ≡ z
--   predl : BiInvInt -> BiInvInt
--   predl-suc : ∀ z -> predl (suc z) ≡ z

open import Cubical.HITs.Ints.BiInvInt

-- Open problem: Is HAEquivInt equivalent to Int?
--
-- data HAEquivInt : Type₀ where
--   zero : HAEquivInt
--   suc : HAEquivInt -> HAEquivInt

--   -- suc is a HAEquiv:
--   pred : HAEquivInt -> HAEquivInt
--   suc-pred : ∀ z -> suc (pred z) ≡ z
--   pred-suc : ∀ z -> pred (suc z) ≡ z
--   coh : ∀ z → (λ i → suc (pred-suc z i)) ≡ suc-pred (suc z)

open import Cubical.HITs.Ints.HAEquivInt

-- DeltaInt:

-- data DeltaInt : Type₀ where
--   _⊖_    : ℕ → ℕ → DeltaInt
--   cancel : ∀ a b → a ⊖ b ≡ suc a ⊖ suc b

open import Cubical.HITs.Ints.DeltaInt



                      ----------------------
                      -- Finite multisets --
                      ----------------------

-- The following definition of finite multisets is due to Vikraman
-- Choudhury and Marcelo Fiore.

infixr 5 _∷_

data FMSet (A : Set) : Set where
  []    : FMSet A
  _∷_   : (x : A) → (xs : FMSet A) → FMSet A
  comm  : ∀ x y xs → x ∷ y ∷ xs ≡ y ∷ x ∷ xs
  trunc : isSet (FMSet A)

_++_ : ∀ {A : Set} (xs ys : FMSet A) → FMSet A
[] ++ ys = ys
(x ∷ xs) ++ ys = x ∷ xs ++ ys
comm x y xs i ++ ys = comm x y (xs ++ ys) i
trunc xs zs p q i j ++ ys =
  trunc (xs ++ ys) (zs ++ ys) (cong (_++ ys) p) (cong (_++ ys) q) i j

-- Proving that this is associative and commutative is easy. See:
open import Cubical.HITs.FiniteMultiset

-- Chuangjie Xu and I proved that FMSet is equivalent to a type a of
-- descending lists (i.e. lists where the elements are in descending
-- order). The map to descending lists corresponds to insertion sort.
open import Cubical.Data.DescendingList

-- We can then transport the ++ operation from FMSet to descending
-- lists together with all of its properties. Chuangjie Xu, Fredrik
-- Nordvall Forsberg and Neil Ghani recently used this in a paper
-- called: "Three equivalent ordinal notation systems in cubical Agda"
-- https://popl20.sigplan.org/details/CPP-2020-papers/25/Three-equivalent-ordinal-notation-systems-in-Cubical-Agda
-- In the paper they define ordinal arithmetic operations using the
-- representation for which it is easiest to work and then transport
-- the operations and their properties to the other types. This is a
-- very cool application of HITs and univalence in logic in my
-- opinion.



-- It is also straightforward to define various truncations:
open import Cubical.HITs.PropositionalTruncation
open import Cubical.HITs.SetTruncation
open import Cubical.HITs.GroupoidTruncation
open import Cubical.HITs.2GroupoidTruncation

-- The general formulation using hub-and-spoke has been developed by
-- Zesen Qian, but not yet merged into master. If someone wants to
-- finish it talk to me.

-- We can also easily define set quotients:
open import Cubical.HITs.SetQuotients
-- Proving that they are effective ((a b : A) → [ a ] ≡ [ b ] → R a b)
-- require univalence for propositions.


-- In another very recent paper with Loïc Pujet called "Cubical
-- Synthetic Homotopy Theory"
-- https://popl20.sigplan.org/details/CPP-2020-papers/15/Cubical-Synthetic-Homotopy-Theory
-- we formalized some classical results from HoTT that were quite
-- complicated to do in Book HoTT. We first formalized the join HIT
-- and proved directly that the join of two circles is S³:
open import Cubical.HITs.Join

-- We then defined the pushout HIT:
open import Cubical.HITs.Pushout
-- and Loïc did a proof of the infamous "3x3 lemma" for pushouts in
-- less than 200LOC. In HoTT-Agda this took about 3000LOC. For details
-- see: https://github.com/HoTT/HoTT-Agda/tree/master/theorems/homotopy/3x3

-- We also defined the Hopf fibration:
open import Cubical.HITs.Hopf
-- and proved that its total space is S³ in about 300LOC.


{-

Future work:

o Do more examples from CS, logic and algebra. Structure identity
  principle should help a lot (Max Zeuner is working on a cubical
  version).

o Try more examples from HoTT, in particular cohomology.

o Try examples where it was infeasible to prove results in Book HoTT,
  e.g. smash product:
-}
open import Cubical.HITs.SmashProduct
